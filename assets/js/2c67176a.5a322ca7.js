"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[419],{2481:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"introducing-skyhook","metadata":{"permalink":"/skyhook/blog/introducing-skyhook","editUrl":"https://github.com/aerospike/skyhook/edit/main/website/blog/blog/2021-08-30-introducing-skyhook.md","source":"@site/blog/2021-08-30-introducing-skyhook.md","title":"Introducing Skyhook","description":"https://dev.to/aerospike/skyhook-a-redis-compatible-interface-to-aerospike-database-4hjj","date":"2021-08-30T00:00:00.000Z","formattedDate":"August 30, 2021","tags":[{"label":"skyhook","permalink":"/skyhook/blog/tags/skyhook"},{"label":"redis","permalink":"/skyhook/blog/tags/redis"},{"label":"aerospike","permalink":"/skyhook/blog/tags/aerospike"}],"readingTime":4.32,"hasTruncateMarker":false,"authors":[],"frontMatter":{"slug":"introducing-skyhook","title":"Introducing Skyhook","tags":["skyhook","redis","aerospike"]}},"content":"> *https://dev.to/aerospike/skyhook-a-redis-compatible-interface-to-aerospike-database-4hjj*\\n\\n[Aerospike](https://www.aerospike.com/) is a highly available and scalable NoSQL distributed database used in production to provide blazingly fast performance at Petabyte scale. Production deployments of Aerospike are almost always serving their data from NVMe drives, though it\u2019s possible to run namespaces in memory.\\n\\nRedis is a well loved key-value data store that is widely used by developers, which was designed to run single node (single-threaded originally) and in-memory.\\nThis article might be interesting to developers who are using [Redis](https://redis.io/) and looking for more scalable and highly available alternatives, or maybe already have some applications running on Aerospike.\\n\\nMigrating to a different technology is always a challenging process. You need to train engineers, rewrite the codebase, and set up a production cluster to take over. Using [Skyhook](https://github.com/aerospike/skyhook), you can move applications to Aerospike first, then come back to rewrite them as Aerospike native, or if you\u2019re satisfied with their performance, keep them as they are.\\nOr maybe you\u2019re looking to expose your Aerospike data to external Redis-based applications? We would love to hear how you would use this project.\\n\\n## Skyhook to the rescue\\n\\nWe, as a company, observed this need and came up with the highly performant bridge service, which acts as a fully-fledged (with commands support limitation) Redis server, bridging the clients\u2019 commands to Aerospike clusters.\\n\\n## Technical details\\n\\nSkyhook is a standalone server application written in Kotlin, which projects Redis protocol commands to an Aerospike cluster using the Aerospike Java client under the hood. The server supports a single namespace and set configuration, where the incoming commands will be applied. This project uses [Netty](https://netty.io/) as a non-blocking I/O client-server framework.\\n\\nNetty, is a highly performant JVM asynchronous event-driven network application framework. Its customizable thread model and native transport support forge an incredibly performant network communication layer.\\n\\nWhat\u2019s left is to translate Redis commands to Aerospike commands, and here come the async capabilities of the Aerospike Java Client.\\n\\n## Installation and configuration\\n\\nYou will need JDK8 and an Aerospike Server version >= 4.9 because Skyhook uses the new scan capabilities which are available starting from that version.\\n\\nClone [aerospike/skyhook](https://github.com/aerospike/skyhook) or grab a prebuilt executable JAR from the [releases](https://github.com/aerospike/skyhook/releases) to get started.\\n\\nTo build the service from the sources:\\n\\n```sh\\n./gradlew clean build\\n```\\n\\nThis command will build an executable JAR file.\\n\\nSkyhook is configured using a configuration file, and it\u2019s in YAML format. You will need to specify it using the `-f` flag.\\n\\nTo run the server:\\n\\n```sh\\njava -jar skyhook-[version]-all.jar -f config/server.yml\\n```\\n\\nAn example configuration file can be found in the config folder under the project repository.\\n\\nHere are the current configuration properties available.\\n\\n| Property name | Description | Default value |\\n| ------------- | ----------- | ------------- |\\n| hostList | The host list to seed the Aerospike cluster. | localhost:3000 |\\n| namespace | The Aerospike namespace. | test |\\n| set | The Aerospike set name. | redis |\\n| bin | The Aerospike bin name to set values. | b |\\n| redisPort | The server port to bind to. | 6379 |\\n| workerThreads<sup>1</sup> | The Netty worker group size. | number of available cores |\\n| bossThreads | The Netty acceptor group size. | 2 |\\n\\n<sup>1</sup> `workerThreads` property is used to configure the size of the Aerospike Java Client EventLoops as well.\\n\\n`workerThreads` and `bossThreads` are the Netty thread pool sizes and can be easily fine-tuned for optimal performance.\\nAfter the server is up and running, any Redis client can connect to it as if it were a regular Redis server.\\n\\nFor the test purposes you can use redis-cli or even the nc (or netcat) utility:\\n\\n```sh\\necho \\"GET key1\\\\r\\\\n\\" | nc localhost 6379\\n```\\n\\n## Benchmarking\\n\\nFrom the very beginning, the project was built with an attention to performance, and the results speak for themselves.\\n\\nRunning this Redis benchmark:\\n\\n```sh\\nredis-benchmark -t set -r 100000 -n 1000000\\n```\\n\\nWe had the following results on local Skyhook with a single-node default configuration Aerospike cluster on Docker:\\n\\n> *Summary:*  \\n>  *throughput summary: 13453.88 requests per second*  \\n>  *latency summary (msec):*  \\n>    *avg       min       p50       p95       p99    max*  \\n>    *3.627     0.864     3.263     5.583     7.463  1012.223*\\n\\nWhile those were the results for the Redis node running on Docker:\\n\\n> *Summary:*  \\n>  *throughput summary: 14967.15 requests per second*  \\n>  *latency summary (msec):*  \\n>    *avg       min       p50       p95       p99    max*  \\n>    *3.275     0.608     2.935     5.087     6.679  1006.591*\\n\\nYou can see that they are really close. More than that, we can multiply the number of the Skyhook nodes and significantly improve performance working with the same aerospike cluster. For instance, you can use the Round-robin DNS or any popular load balancer like HAProxy. This will not require any specific configuration since Skyhook is completely stateless.\\n\\n## Summary\\n\\nThe project is constantly evolving, having more and more commands being supported. You can find the coverage of the supported Redis commands in the [repo readme](https://github.com/aerospike/skyhook).\\n\\nIt will be really great to hear from you about the experience of using it. Also, your contributions to the project are very welcome.\\n\\nIf you encounter a bug, please report it or [open an issue](https://github.com/aerospike/skyhook/issues) stating the commands you would like to be supported."}]}')}}]);